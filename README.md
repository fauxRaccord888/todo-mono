# 레포지토리 소개
- 기초적인 수준의 `TODO 리스트`를 여러 프레임워크를 통해 구축합니다.
- 여러 프레임워크를 통해 구축한 결과물을 `Astro`를 통해 동시에 렌더링합니다.
    - 한 프레임워크에서 만든 변화를 다른 프레임워크에 `reactive`하게 반영되도록 만듭니다.
- 공통으로 사용하게 되는 내용은 `/shared`에 패키지화합니다.
- 학습을 목표로 하는 저장소이므로 별도의 개발자 문서는 작성하지 않습니다.
- 주된 목표는 `빠른 시간` 내에 `여러` 프레임워크를 경험하는 것입니다.
    - 이를 통해 프론트엔드 웹프레임워크가 해결하는 `문제`가 무엇인지 이해합니다.
        - `리액트` 이전의 초기 프레임워크들(Backbone, Knockout, Angular, Ember)은 다루지 않습니다.
        - Htmx, Alpine, Stencil, Marko는 필요한 경우 다시 방문합니다. (해결하는 문제가 상이함)
    - 반복적으로 등장하는 개념을 통해 `중요 개념`을 익힙니다.
        - 다른 프레임워크에는 존재하지 않는 `특이한 편의 기능`과 `일반적 기능`을 구분합니다.
        - 각 프레임워크들이 특정한 목적을 달성하기 위해 사용하는 `수단`을 이해합니다.

# 프로젝트의 학습 목표
## 개별 프레임워크 수준
- 각 프레임워크에서 사용하는 `상태`, `컴포넌트`, `변화`, `복잡성 관리`를 이해합니다.
### `상태(state)`와 `속성(property)`에 대해 이해합니다. 
- `상태`와 `속성`의 차이를 이해합니다.
    - 상태에 `종속`적인 속성을 이해합니다.
    - `중복`되는 속성을 어떻게 줄이는지 이해합니다.
- 속성을 `직접 조작`하지 않는 이유를 이해합니다. [변화와 이벤트](#변화와-이벤트에-대해-이해합니다)
    - 변수를 직접 조작하고 이에 반응하는 일부 프레임워크를 살펴봅니다.

### `컴포넌트`와 `부수 작용(side-effect)`을 이해합니다.
- `순수 함수`를 이해합니다.
    - 순수 함수와 side-effect를 이해합니다.
    - 동일 입력에 대한 동일 출력으로서 컴포넌트를 이해합니다.
    - 원본을 `복제`하는 이유와 `중첩된 객체`의 복제를 이해합니다.
    - 순수성을 유지하며 `변화`를 발생시키는 방법을 고민해봅니다. 
        - `예외`를 이해합니다.(로컬 뮤테이션, 이벤트 핸들러)
    - `React.StrictMode`가 2회 렌더링 하는 이유를 이해합니다.
    - 덜 순수한(side-effect를 일으켜도 되는) 프레임워크들도 살펴봅니다.

- `생명 주기`를 이해합니다.(`가상 DOM`을 사용하는 경우)
    - `가상 DOM`과 `실제 DOM`의 차이를 이해합니다.
        - `가상 DOM`에서 직접 접근할 수 없는 속성들을 이해합니다.
        - `실제 DOM`에 접근할 수 있도록 만드는 방법을 이해합니다.
    - `렌더링`과 `함수의 호출`이 동치임을 이해합니다.
        - `반복적`으로 필요한 부분과 `선택적`으로 필요한 부분을 이해합니다.
        - `선택적`으로 필요한 함수를 필요한 때에 호출하는 법을 이해합니다.
    - `clean up`을 이해합니다.
        - 리렌더링 시에 `중복 호출`로 발생하는 `기대하지 않은 작동`을 이해합니다.
        - 이러한 부분을 해결할 수 있는 `clean up`을 이해합니다.

### `변화`와 `이벤트`에 대해 이해합니다.
- `상태`의 `변화`를 이해합니다.
    - `함수`를 통한 `상태`의 변화를 이해합니다.
    - `상태`를 직접 변화시키지 않아야 하는 이유를 이해합니다.
- `상태`를 직접 변화시키는 일부 프레임워크를 살펴봅니다.
    - 일부 프레임워크에서 사용하는 `emit`과 `리액트` 모델의 차이를 이해합니다.
    - `단방향 데이터 흐름`과 `양방향 바인딩`의 차이를 이해합니다.

### `상태`와 `상태의 변화`에 따른 `복잡성`을 관리하는 법을 이해합니다.
- `전역성`과 `지역성`을 이해합니다.
- `store`와 `context`를 이해합니다.
- `signal`과 `proxy`를 이해합니다.


# 함양하고자 하는 역량
- 학습 능력
    - 공식 문서를 읽고, 학습하는 능력을 배양합니다.
- 문제 해결 능력
    - API로부터 기능 명세를 충족하는 코드를 작성하는 능력을 배양합니다.
    - 필요한 기능을 찾고 이를 구현하는 능력을 배양합니다.
    - 특정한 기능이 존재하지 않을 때, 이에 대응하는 능력을 배양합니다.
    - 레거시 코드가 신규 프로젝트의 기술 스택과 다른 상황에 익숙해집니다.
- 추상화 능력
    - 여러 프레임워크로 유사한 내용을 반복 구현함으로써 추상화 가능한 부분을 파악하는 능력을 배양합니다.

# 학습 내용 요약
## `POJO` vs `Class`
- `POJO`의 장점
    - `Class`의 메서드로 상태를 변경할 경우, 추적이 어려움
        - `Class`를 사용할 경우 `Proxy`로 감싸는 방식의 `Signal`을 고장냄
        - `변화 과정`과 `직렬화 과정`이 중복됨(Class에서 수행한 뒤, 프레임워크에서 다시 수행)
    - `상태`의 `변화`를 상위 수준에서 취급하는 멘털 모델에 적합함
        - `Class`를 사용하는 경우, 하위 레벨인 인스턴스의 메서드를 통해 직접 변화함
        - `Redux`의 문서도 상태를 `Plain Object`로 관리하기를 주문
- `Class`의 장점
    - `변화`를 촉발하는 방법이 프레임워크마다 달라서 매번 작성해야 하는 부분을 대체할 수 있음
        - 하지만 실질적으로 이 문제는 `Class` 문법을 통해 `상쇄되지 않음`
    - `ESSerializer` 등의 직렬화 라이브러리를 통해 `local storage`를 자유롭게 이용할 수 있음
        - 실제 `API response`는 `JSON` 형식일 확률이 높으므로 `상쇄`되는 장점
        - `Date` 객체를 제외하면 `JSON` 객체의 직렬화 메소드와 유의미한 차이 없음

## `Key`가 필요한 경우
- 일부 프레임워크에서는 순회 렌더링 과정에서 `Key`가 필요함
    - 렌더링 시에 발생하는 오버헤드를 줄이기 위함
    - `signal`을 사용하는 경우와 달리, 반응성 관리를 `관찰자 패턴`을 사용하지 않는 경우에 해당
        - 특히 `React`에서 중요
            - `Object.is()`를 통해 비교함
            - `UI 트리`의 인덱스에 따라 `state`를 관리함
    - 데이터에 `고유 키`가 존재해야 모든 프레임워크에서 성능 상 이점을 취할 수 있음
    - `DB`에서 데이터를 받아올 경우, 그 고유키를 키로 사용하는 것이 `리액트 문서`의 추천 사항
